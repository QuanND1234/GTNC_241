# -*- coding: utf-8 -*-
"""thread_time_out.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zNKnGCBwuoqLGsac44m1UMbLxw2lRR30
"""

# NOTE: you CAN change this cell
# If you want to use your own database, download it here
# !gdown ...
# Remove old files
# !rm -rf list_province.txt list_district.txt list_ward.txt data_autocorrect.csv db_VN_2.csv db_VN.csv trie.py utils.py

# !wget 'https://drive.usercontent.google.com/download?id=1MMPVf05Bt-0Bij3p_KKOJaOOxNsh3HFW&export=download&authuser=1&confirm=t&uuid=6201d8ba-3ead-4ae4-94e8-9ba5fd694a89&at=AENtkXb1d3XrF853klhQ-e8l_7Bc:1731436257399' -O data_autocorrect.csv
# !wget 'https://drive.usercontent.google.com/download?id=12pjdV0ojqh_5s-kEXcE2d_tlpNph-QT-&export=download&authuser=1&confirm=t&uuid=a0523805-0939-4d92-9d4e-ce857a6f0ff6&at=AENtkXa30MM7bdroq9LaG5lH9SEx:1731436381935' -O db_VN_2.csv
# !wget 'https://drive.usercontent.google.com/download?id=1vIX9cSrOhDAQkqdNZUPTcBBB9iPXw0cr&export=download&authuser=1&confirm=t&uuid=0da938e0-972c-4d7d-ad0e-10956f439f19&at=AENtkXacFY3xq7FSMneHja3nsO0C:1731436412769' -O db_VN.csv
# !wget 'https://drive.usercontent.google.com/download?id=1RDcC34PnmMSaIxDBNdOdBsbYrZvgfRvV&export=download&authuser=1&confirm=t&uuid=d901fcf8-caf5-4c9c-8b5b-90acfa635ac6&at=AENtkXaKk4cecv2ABUdBihiffwTV:1731436439337' -O trie.py
# !wget 'https://drive.usercontent.google.com/download?id=1u-kfNm5Xbt402uKOLh2C8fMJfGI-aQJI&export=download&authuser=1&confirm=t&uuid=8ae39107-a6b9-49e2-b91d-528357f24c7e&at=AENtkXY0jneuIC04cWz3Tgi2lv0U:1731439918883' -O utils.py
# # this link is public test
# !gdown --fuzzy https://drive.google.com/file/d/15vyI38GkCs40Vv9Yho5C5jWO9TsXimJ5/view?usp=drive_link -O list_ward.txt
# !gdown --fuzzy https://drive.google.com/file/d/1kPo0d2mqrmlXDiWirLPd6ZFHWDXNRUGV/view?usp=drive_link -O list_district.txt
# !gdown --fuzzy https://drive.google.com/file/d/1YD1S15-BMmooS7yQyTj8vMA4yiWxNVY2/view?usp=drive_link -O list_province.txt

# # NOTE: you CAN change this cell
# # Add more to your needs
# # you must place ALL pip install here
# !pip install editdistance
# !pip install unidecode
# !pip uninstall func_timeout

# NOTE: you CAN change this cell
# import your library here
from trie import Trie
import threading
import multiprocessing
import pandas as pd
import math
import numpy as np
import string
import re
import random
import time
from tqdm import tqdm
from collections import Counter
import unicodedata
import unidecode
import itertools
from utils import *
from ThreadTimeout import func_timeout, FunctionTimedOut,func_set_timeout

# NOTE: you MUST change this cell
# New methods / functions must be written under class Solution.
class Solution:
    def __init__(self):
        # list provice, district, ward for private test, do not change for any reason

        self.province_path = 'list_province.txt'
        self.district_path = 'list_district.txt'
        self.ward_path = 'list_ward.txt'

        self.setup_trie()
        self.setup_bktree()

    ############### START TRIE REGION ###############
    def setup_trie(self):
        #DB
        data = pd.read_csv('data_autocorrect.csv')
        data = data.replace(np.nan, '', regex=True)
        data = data.astype(str)
        data['delete'] = [a == "" or b == "" or c == "" for a,b,c in zip(data['province'], data['district'], data['ward'])]
        data2 = data[data['delete'] == False]
        self.data = data

        db = pd.concat(
        [
            pd.read_csv('db_VN.csv').astype(str),
            pd.read_csv('db_VN_2.csv').astype(str)
        ])

        db = db.rename(columns = {
            'Tỉnh Thành Phố': 'province',
            'Quận Huyện' : 'district',
            'Phường Xã' : 'ward'
        })
        db = db.drop_duplicates(subset = ['province', 'district','ward'] ,keep = 'first')

        mapping = {}
        db_dict = {}


        db = pd.concat([db, data2])

        for city in list(db['province'].unique()):
            db_city = db[db['province'] == city]
            db_dict[city] = {}
            mapping[city] = {}
            for district in list(db_city['district'].unique()):
                db_district = db_city[db_city['district'] == district]
                db_dict[city][remove_sign(district.replace('Quận ', '').replace('Thành phố  ', '').replace('Thành phố ', '').replace('Huyện ', ''  ).replace('Thị xã ', '').replace(' ', ''))] = []

                mapping[city][remove_sign(district.replace('Quận ', '').replace('Thành phố  ', '').replace('Thành phố ', '').replace('Huyện ', ''  ).replace('Thị xã ', '').replace(' ', ''))] = district.replace('Quận ', '').replace('Thành phố  ', '').replace('Thành phố ', '').replace('Huyện ', '').replace('Thị xã ', '')



        self.db = db
        self.mapping = mapping
        self.db_dict = db_dict
        self.trie_province = self.build_province_trie()
        self.trie_district = self.build_district_trie()

    def build_province_trie(self):
        trie_province = Trie()

        province_lst = list(zip(list(self.data['province'].unique()), list(self.data['province'].unique())))

        additional = [
            ('TPHCM', 'Hồ Chí Minh'),
            ('TP.HCM', 'Hồ Chí Minh'),
            ('T.P H.C.Minh', 'Hồ Chí Minh'),
            ('TGiang', 'Tiền Giang'),
            ('T.Giang', 'Tiền Giang'),
            #('HN', 'Hà Nội'),
            ('Thừa.t.Huế' , 'Thừa Thiên Huế'),
            #('TTH' , 'Thừa Thiên Huế')
        ]

        province_lst.extend(additional)

        # province_lst = ["Đà Nẵng"]


        sum = 0

        final_possible_province_lst = []
        for province_tuple in tqdm(province_lst):
            original_province, real_name = province_tuple
            start = time.time()
            possible_province_lst = []
            if original_province == 'nan':
                continue
            if len(original_province) < 3:
                trie_province.insert(original_province, real_name)
                continue
            province = pre_process(original_province)
            possible_province_lst += [province]

            possible_remove_lst = remove_char(province)
            possible_remove_lst += [province]
            possible_province_lst += possible_remove_lst

            province_insert_lst = []
            for word in [province]:
                province_insert_lst.extend(insert_char(word ))
            possible_province_lst += province_insert_lst


            possible_change_lst = []
            for word in [province]:
                possible_change_lst.extend(change_char(word ))
            possible_province_lst += possible_change_lst


            sum += len(possible_province_lst)
            #print(time.time() - start)

            possible_province_lst = set(possible_province_lst)
            #print(len(possible_province_lst))
            final_possible_province_lst.extend(possible_province_lst)

            for possible_province in possible_province_lst:
                trie_province.insert(possible_province, real_name)

        trie_province.insert(pre_process('HN'), 'Hà Nội')
        #trie_province.insert(pre_process('PHOHN'), 'Hà Nội')
        trie_province.insert(pre_process('H.N'), 'Hà Nội')
        trie_province.insert(pre_process('TTH'), 'Thừa Thiên Huế')
        trie_province.insert(pre_process('T.T.H'), 'Thừa Thiên Huế')
        return trie_province

    def build_district_trie(self):
        trie_district = Trie()

        district_lst = list(zip(list(self.data['district'].unique()), list(self.data['district'].unique())))

        additional = [
        ]

        district_lst.extend(additional)

        # province_lst = ["Đà Nẵng"]


        sum = 0

        for district_tuple in tqdm(district_lst):
            original_district, real_name = district_tuple
            start = time.time()
            possible_district_lst = []
            if original_district == 'nan':
                continue
            if len(original_district) < 3:
                trie_district.insert(original_district, real_name)
                continue
            district = pre_process(original_district)
            possible_district_lst += [district]

            possible_remove_lst = remove_char(district)
            possible_remove_lst += [district]
            possible_district_lst += possible_remove_lst

            district_insert_lst = []
            for word in [district]:
                district_insert_lst.extend(insert_char(word ))
            possible_district_lst += district_insert_lst


            possible_change_lst = []
            for word in [district]:
                possible_change_lst.extend(change_char(word ))
            possible_district_lst += possible_change_lst


            sum += len(possible_district_lst)
            #print(time.time() - start)

            possible_district_lst = set(possible_district_lst)
            #print(len(possible_province_lst))

            for possible_district in possible_district_lst:
                trie_district.insert(possible_district, real_name)
        return trie_district

    def search_city(self, raw_text):
      max_length = min(len(raw_text), 15)
      #print(raw_text)
      text = pre_process(raw_text)
      #print(text)

      true_word_lst = []
      search_text_lst = []
      _result = False
      for i in range(2, max_length):
          search_text = text[:i]


          result, true_word, flex_word = search(search_text, self.trie_province)

          #print(true_word)
          if true_word is None:
              true_word = []
          elif len(true_word) == 1:
              true_word = true_word[0]
          else:
              best_true_word = ""
              min_true_score = 999
              for _true_word in true_word:

                  true_score = levenshtein_distance(_true_word[-i:], raw_text[-i:])
                  #print(_true_word, true_score)
                  if true_score < min_true_score:
                      best_true_word = _true_word
                      min_true_score = true_score
              true_word = best_true_word
          #print(result, true_word, flex_word, search_text)
          if result == True:
              _result = True
              search_text_lst.append(search_text)
              true_word_lst.append(true_word)
      #print(true_word_lst)
      if len(true_word_lst) > 0:
          final_candidate = ""
          min_score = 999
          len_part = 999
          #print(true_word_lst)
          #for candidate in
          for candidate in set(true_word_lst):
              sum_score = 0
              for part in search_text_lst:
                  sum_score += levenshtein_distance(pre_process(candidate), part)
              if sum_score < min_score:
                  min_score = sum_score
                  final_candidate = candidate
                  len_true_word = len(part)

              #print(candidate, sum_score, final_candidate)
          # counter = Counter(true_word_lst)
          # most_common_element = counter.most_common(1)[0][0]
      else:
          final_candidate = ""
          len_true_word = 0

      # print(most_common_element)
      if "-" in final_candidate:
          len_true_word += 3

      return(_result, final_candidate, len_true_word)


    def search_district(self, raw_text, city, min_threshold = 0.29):
      #print(raw_text)
      raw_text = raw_text.replace('Tỉnh', '').replace('tỉnh', '').replace('tỉn', '').replace('Tỉn', '').replace('Tỉ,nh', '').replace('Tinh', '').replace('Tnh', '')
      raw_text = remove_sign(raw_text)
      raw_text = upper(raw_text)
      raw_text = raw_text.replace(' ','').replace(',','').replace('.','').replace('TP', '').replace('TY', '').replace('THANHPHO','').replace('THANHMPHO', '').replace('THANHPH', '')

      #print(raw_text)
      max_length = min(len(raw_text) + 1, 15)

      # min_score = 999
      # best_candidate = ""


      if city != "":
          for i in range(1, max_length, 1):
              text = raw_text[-i:]
              #text = text.replace(' ','').replace(',','').replace('TP', '')
              #text = remove_sign(text)
              #print(text)
              if text == '':
                  continue
              for candidate in sorted(self.db_dict[city].keys(), key = len, reverse=True):
                  if candidate.isdigit() and candidate in text:
                      if raw_text[-i - 1].isdigit():
                          continue
                      return True, self.mapping[city][candidate], len(self.mapping[city][candidate])
                  search_candidate = upper(candidate)
                  score = levenshtein_distance(text, search_candidate)
          #       print(text, candidate, score, min_threshold*len(text))
                  if score < min_threshold*len(text):
                      return True, self.mapping[city][candidate], len(self.mapping[city][candidate])

          return False, "", 0
      else:
          #return False, "", 0
          _result = False
          true_word_lst = []
          search_text_lst = []
          text = pre_process(raw_text)
          for i in range(1, max_length, 1):
              search_text = text[:i]
              result, true_word, flex_word = search(search_text, self.trie_district)

              if true_word is None:
                  true_word = []
              elif len(true_word) == 1:
                  true_word = true_word[0]
              else:
                  best_true_word = ""
                  min_true_score = 999
                  for _true_word in true_word:

                      true_score = levenshtein_distance(_true_word[-i:], raw_text[-i:])
                      #print(_true_word, true_score)
                      if true_score < min_true_score:
                          best_true_word = _true_word
                          min_true_score = true_score
                  true_word = best_true_word
              #print("1", result, true_word, flex_word, search_text)
              if result == True:
                  _result = True
                  search_text_lst.append(search_text)
                  true_word_lst.append(true_word)


          if len(true_word_lst) > 0:
              final_candidate = ""
              min_score = 999
              len_part = 999
              for candidate in set(true_word_lst):
                  sum_score = 0
                  for part in search_text_lst:
                      sum_score += levenshtein_distance(pre_process(candidate), part)
                  if sum_score < min_score:
                      min_score = sum_score
                      final_candidate = candidate
                      len_true_word = len(part)
                  #print("2", candidate, sum_score, final_candidate)
          else:
              final_candidate = ""
              len_true_word = 0

          return(_result, final_candidate, len_true_word)

    ############### END TRIE REGION ###############


    ############### START BKTREE REGION ###############
    class Node:
      def __init__(self, x=None):
          self.word = x
          self.next = [0] * 2000
    class BKTree:
      def __init__(self):
          self.maxn  = 10000
          self.tol = 5
          self.len = 10
          self.root = Solution.Node()
          self.ptr = 0
          self.tree = [Solution.Node() for _ in range(self.maxn)]

      def add(self, curr):
        def _add(root, curr):
          if not root.word:
              root.word = curr.word
              root.next = curr.next
              return

          dist = Solution.BKTree.edit_distance(curr.word, root.word)
          if not self.tree[root.next[dist]] or not self.tree[root.next[dist]].word:
              self.ptr += 1
              self.tree[self.ptr] = curr
              root.next[dist] = self.ptr
          else:
              _add(self.tree[root.next[dist]], curr)

        return _add(self.root, curr)

      def search(self, s):
        def _search(root, s):
          ret = []
          if not root or not root.word:
              return ret

          dist = Solution.BKTree.edit_distance(root.word, s)
          if dist <= self.tol:
              ret.append(root.word)

          start = dist - self.tol if dist - self.tol > 0 else 1
          while start <= dist + self.tol:
              tmp = _search(self.tree[root.next[start]], s)
              ret += tmp
              start += 1
          return ret # return pair (word, distance)

        return _search(self.root, s)

      @staticmethod
      def edit_distance(a, b):
          m, n = len(a), len(b)
          dp = [[0] * (n + 1) for _ in range(m + 1)]
          for i in range(m + 1):
              dp[i][0] = i
          for j in range(n + 1):
              dp[0][j] = j

          for i in range(1, m + 1):
              for j in range(1, n + 1):
                if a[i - 1] != b[j - 1]:
                      dp[i][j] = min(
                          dp[i - 1][j] + 1,  # deletion
                          dp[i][j - 1] + 1,  # insertion
                          dp[i - 1][j - 1] + 2  # replacement
                      )
                else:
                      dp[i][j] = dp[i - 1][j - 1]
          return dp[m][n]

    def setup_bktree(self):
        self.root_district = Solution.BKTree()
        self.root_province = Solution.BKTree()
        self.root_ward = Solution.BKTree()

        # Adjustables
        self.max_distance = 3
        self.stopwords = ['tha6nhpho', 'thanhpho', 'thanh pho', 'thi xa', 'thixa' ,'thi tran', 'phuong', 'huyen', "hyen", "huyn", 'tinh', 'quan ', 'tp', 't.p', 'tp.', 'tt.', 'tx.', 't.x.', 't.x', 'tnh', 'tg.', 'tin', 'tt', 'tt', 'xa', 'h.', 'x.', 't.', 'q.', 'tx', 'x2', 'h ']
        province_sw = ['tha6nhpho', "thanhmpho", "thanhpho", "thanhfho", "tinh", 't.pho', "tp", "t.y", "ty.", "t.p", "Tp.", "tnh", "t.", "tin", "tnh", 'tg.']
        province_sw.sort(key=lambda x: len(x), reverse=True)
        district_sw = ["thanh pho", 'tha6nhpho', "thanhfho", "thanhpho", "tp", 't.pho', "t.p", "Tp.", "tnh", "huyen", "hyen", "huyn", "quan", "q.", "h.", 'thi xa', 'thixa', 'hixa', 'ixa']
        district_sw.sort(key=lambda x: len(x), reverse=True)
        ward_sw = ["phuong", "phg", "ph", "p.", "xa", "x.", "thitran", "tt", "tt.", "thitr", "thtran", "thtr", "f."]
        ward_sw.sort(key=lambda x: len(x), reverse=True)
        self.stopwords_dict = {
            "province": province_sw,
            "district": district_sw,
            "ward": ward_sw
        }

        self.province_sanitized_map = dict()
        self.district_sanitized_map = dict()
        self.ward_sanitized_map = dict()
        self.whitelisted_province = []
        self.whitelisted_district = []
        self.whitelisted_ward = []

        self.read_file()
        self.build_tree()

    def remove_special_characters(self, text, remove_space=True, lowercase=True):
        text = unidecode.unidecode(text)  # Loại bỏ dấu
        # pattern = f"[{re.escape(string.punctuation)}]"
        # text = re.sub(pattern, "", text)  # Loại bỏ ký tự đặc biệt
        if remove_space: text = re.sub(r'\s+', '', text)  # Loại bỏ khoảng trắng
        if lowercase: text = text.lower()               # In thường
        return text

    def generate_initial_combinations(self, text):
        words = text.split()

        # Generate all combinations of full words and initials for each word
        word_combinations = []
        for word in words:
            word_combinations.append([word, word[0] + "."])  # Add full word and initial with period

        # Generate all possible combinations using itertools.product
        all_combinations = list(itertools.product(*word_combinations))

        # Join the combinations into strings and return
        initial_combinations = ["".join(comb) for comb in all_combinations]
        return initial_combinations

    def read_file(self):
        province_data = open(self.province_path, encoding='utf8')
        district_data = open(self.district_path, encoding='utf8')
        ward_data = open(self.ward_path, encoding='utf8')
        district_prefixes = ["quan", "q", "qn", "q.", "qn."]
        ward_prefixes = ["phuong", "p", "f", "p.", "f."]

        for line in province_data:
            data = line.replace('\n', '')
            self.province_sanitized_map[self.remove_special_characters(data)] = data
            initials = self.generate_initial_combinations(self.remove_special_characters(data, remove_space=False))
            for initial in initials:
              self.province_sanitized_map.setdefault(initial, data)

        for line in district_data:
            data = line.replace('\n', '')
            s_data = self.remove_special_characters(data)
            self.district_sanitized_map[s_data] = data
            if data.isdigit():
              for prefix in district_prefixes:
                self.district_sanitized_map.update({f"{prefix}{s_data}": data})

        for line in ward_data:
            data = line.replace('\n', '')
            s_data = self.remove_special_characters(data)
            self.ward_sanitized_map[self.remove_special_characters(data)] = data
            if data.isdigit():
              for prefix in ward_prefixes:
                self.ward_sanitized_map.update({f"{prefix}{s_data}": data})
        province_custom_map = {
            "t.t.h": "Thừa Thiên Huế",
            "thua.t.hue": "Thừa Thiên Huế",
            "thua.thien.hue": "Thừa Thiên Huế",
            "hcm": "Hồ Chí Minh",
            "ho.chi.minh": "Hồ Chí Minh",
            "h.c.m": "Hồ Chí Minh",
            "h.c.m.": "Hồ Chí Minh"
        }
        self.province_sanitized_map.update(province_custom_map)

    def build_tree(self):
        for district in self.district_sanitized_map.keys():
            district_node = Solution.Node(self.remove_special_characters(district))
            self.root_district.add(district_node)
        for province in self.province_sanitized_map.keys():
            province_node = Solution.Node(self.remove_special_characters(province))
            self.root_province.add(province_node)
        for ward in self.ward_sanitized_map.keys():
            ward_node = Solution.Node(self.remove_special_characters(ward))
            self.root_ward.add(ward_node)

    def remove_stopwords_from_address(self, address: str):
        chunks = address.lower().split(",")

        clear_chunks = []

        # CONSTANTS
        HEAD_SW_SIZE = 7
        DIST_ALLOWED = 2
        WINDOW_ALLOWED = 9
        OFFSET = 2

        self.whitelisted_province = filter(lambda x: len(x) >= WINDOW_ALLOWED - DIST_ALLOWED, self.province_sanitized_map.keys())
        self.whitelisted_district = filter(lambda x: len(x) >= WINDOW_ALLOWED - DIST_ALLOWED, self.district_sanitized_map.keys())
        self.whitelisted_ward = filter(lambda x: len(x) >= WINDOW_ALLOWED - DIST_ALLOWED, self.ward_sanitized_map.keys())

        def should_elim_prefix_stopword(chunk, stopword):
            head = chunk[:HEAD_SW_SIZE]
            return (len(chunk) >= 1.75*len(stopword) or chunk[len(stopword):].isdigit()) and (chunk.startswith(stopword) or Solution.BKTree.edit_distance(head, stopword) <= DIST_ALLOWED)

        # A. COMMA >= 2
        if len(chunks) >= 3:
            for i in range(len(chunks) - 1, -1, -1):
                # Basic sanitization
                chunk = self.remove_special_characters(chunks[i])
                # Remove stopwords
                for stopword in self.stopwords:
                    if should_elim_prefix_stopword(chunk, stopword):
                        chunk = chunk[len(stopword):]
                        break
                # We are in the Province chunk
                if i == 2:
                    jump_to_next_chunk = False
                    # It is longer than expected -> may contain District
                    if len(chunk) > WINDOW_ALLOWED:
                        is_whitelist = False
                        # Sanit. A.1: Contains Whitelist word
                        for wl_province in self.whitelisted_province:
                            if Solution.BKTree.edit_distance(chunk, wl_province) <= DIST_ALLOWED:
                                is_whitelist = True
                                province = self.remove_special_characters(wl_province)
                                clear_chunks.append(province)
                                break
                        if is_whitelist: continue
                        # Sanit. A.2: Contains Stop word
                        for sw_district in self.stopwords_dict["province"]:
                            if sw_district in chunk:
                                jump_to_next_chunk = True
                                sp = chunk.split(sw_district)
                                province = sp[1]
                                district = sp[0]
                                if len(province) < 4:
                                  clear_chunks.append("")
                                  break
                                clear_chunks.append(province)
                                if len(district) < 3 and not district.isdigit(): break
                                clear_chunks.append(district) if len(district) <= WINDOW_ALLOWED else clear_chunks.append(district[-WINDOW_ALLOWED:])
                                break
                        if jump_to_next_chunk: continue
                        # Sanit. A.3: Not Whitelisted or Stop Word
                        province = self.remove_special_characters(chunk[-len(chunk)//2 - OFFSET:])
                        district = self.remove_special_characters(chunk[:-len(chunk)//2 + OFFSET])
                        if province != district:
                            jump_to_next_chunk = True
                            if len(province) < 3: continue
                            clear_chunks.append(province)
                            if len(district) < 3 and not district.isdigit(): continue
                            clear_chunks.append(district) if len(district) <= WINDOW_ALLOWED else clear_chunks.append(district[-WINDOW_ALLOWED:])
                            if len(clear_chunks) == 3: return clear_chunks
                    # Normal length
                    else:
                        clear_chunks.append(chunk)
                # We are in the District chunk
                if i == 1:
                    jump_to_next_chunk = False
                    # It is longer than expected -> may contain Ward
                    if len(chunk) > WINDOW_ALLOWED:
                        is_whitelist = False
                        # Sanit. A.1: Contains Whitelist word
                        for wl_district in self.whitelisted_district:
                            if Solution.BKTree.edit_distance(chunk, wl_district) <= DIST_ALLOWED:
                                is_whitelist = True
                                district = self.remove_special_characters(wl_district)
                                clear_chunks.append(district)
                                break
                        if is_whitelist: continue
                        # Sanit. A.2: Contains Stop word
                        for sw_district in self.stopwords_dict["district"]:
                            if sw_district in chunk:
                                sp = chunk.split(sw_district)
                                district = self.remove_special_characters(sp[1])
                                ward = self.remove_special_characters(sp[0])
                                if len(district) < 3 and not district.isdigit(): break
                                jump_to_next_chunk = True
                                clear_chunks.append(district)
                                if len(ward) < 3 and not ward.isdigit(): break
                                clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
                                if len(clear_chunks) == 3: return clear_chunks
                                break
                        if jump_to_next_chunk: continue
                        # Sanit. A.3: Not Whitelisted or Stop Word
                        district = self.remove_special_characters(chunk[-len(chunk)//2 - OFFSET:])
                        ward = self.remove_special_characters(chunk[:-len(chunk)//2 + OFFSET])
                        if district != ward:
                            jump_to_next_chunk = True
                            if len(district) < 3 and not district.isdigit(): continue
                            clear_chunks.append(district)
                            if len(ward) < 3 and not ward.isdigit(): continue
                            clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
                            if len(clear_chunks) == 3: return clear_chunks
                    # Normal length, but be careful
                    else:
                        for sw_district in self.stopwords_dict["district"]:
                            if sw_district in chunk:
                                sp = chunk.split(sw_district)
                                district = self.remove_special_characters(sp[1])
                                ward = self.remove_special_characters(sp[0])
                                if len(district) < 3 and not district.isdigit(): break
                                jump_to_next_chunk = True
                                clear_chunks.append(district)
                                if len(ward) < 3 and not ward.isdigit(): break
                                clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
                                if len(clear_chunks) == 3: return clear_chunks
                                break
                        district = self.remove_special_characters(chunk)
                    if not jump_to_next_chunk: clear_chunks.append(district)
                    continue
                # We are in the Ward chunk
                if len(clear_chunks) == 3: return clear_chunks
                if i == 0:
                    # It is longer than expected, may contain house numbers
                    if len(chunk) > WINDOW_ALLOWED:
                        is_whitelist = False
                        word, min_dist = "", float('inf')
                        for wl_ward in self.whitelisted_ward:
                            dist = Solution.BKTree.edit_distance(chunk, wl_ward)
                            if dist <= DIST_ALLOWED and dist < min_dist:
                                min_dist = dist
                                word = wl_ward
                                is_whitelist = True
                        if is_whitelist: ward = self.remove_special_characters(word)
                        else:
                          ward = self.remove_special_characters(chunk[-WINDOW_ALLOWED:])
                          for sw_ward in self.stopwords_dict["ward"]:
                            if should_elim_prefix_stopword(ward, sw_ward):
                                ward = ward[len(sw_ward):]
                    # Else, it is normal
                    else:
                        ward = self.remove_special_characters(chunk)
                    clear_chunks.append(ward)
                # If there are many commas, just append the rest of them
                if i > 2:
                    clear_chunks.append(chunk)
            return clear_chunks
        # B. COMMA = 1 (lack 1 comma)
        elif len(chunks) == 2:
          # B.1 Lack of comma to separate province and district
          ## Identify: If length of Province > WINDOW_ALLOWED and not in whitelist province
          if len(chunks[1]) > WINDOW_ALLOWED - 1:
            # print(1)
            # Whitelist Province flow
            is_whitelist_province = False
            # Remove stopwords from the Province
            chunk1 = self.remove_special_characters(chunks[1])
            for stopword in self.stopwords_dict["province"]:
                if should_elim_prefix_stopword(chunk1, stopword):
                    chunk1 = chunk1[len(stopword):]
                    break
            # Whitelist Check
            word, min_dist = "", float('inf')
            for wl_province in self.whitelisted_province:
                dist = Solution.BKTree.edit_distance(chunk1, wl_province)
                if dist <= DIST_ALLOWED and dist < min_dist:
                    is_whitelist_province = True
                    word = wl_province
                    min_dist = dist
            if is_whitelist_province:
                province = self.remove_special_characters(word)
                clear_chunks.append(province)
                # If we can find a stopword, we can split from it
                is_separable_by_district_sw = False
                # Remove stopwords from the Ward & District
                chunk = self.remove_special_characters(chunks[0])
                for stopword in self.stopwords_dict["district"] + self.stopwords_dict["ward"]:
                    if should_elim_prefix_stopword(chunk, stopword):
                        chunk = chunk[len(stopword):]
                        break
                for stopword in self.stopwords_dict["district"]:
                    if stopword in chunk:
                        is_separable_by_district_sw = True
                        anchor = chunk.rfind(stopword)
                        if anchor == len(chunk) - len(stopword): # stopword is at the end -> not an actual stopword
                            if len(chunk) >= WINDOW_ALLOWED:
                                district = chunk[-len(chunk)//2 - OFFSET:]
                                ward = chunk[:-len(chunk)//2 + OFFSET]
                                clear_chunks.append(district)
                                clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
                                break
                            clear_chunks.append(chunk)
                            break
                        district = self.remove_special_characters(chunk[anchor+len(stopword):]) # district part
                        ward = self.remove_special_characters(chunk[:anchor]) # ward part
                        clear_chunks.append(district)
                        if len(ward) < 2: break
                        clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
                        break
                # Else, we can split from the last WINDOW_ALLOWED chars
                if not is_separable_by_district_sw:
                  if len(chunk) > WINDOW_ALLOWED:
                      district = chunk[-len(chunk)//2 - OFFSET:]
                      ward = chunk[:-len(chunk)//2 + OFFSET]
                      clear_chunks.append(district)
                      clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
                  else: clear_chunks.append(chunk)
                return clear_chunks
            # Non Whitelist Province flow
            # If we can find a stopword, we can split from it
            is_separable_by_province_sw = False
            for stopword in self.stopwords_dict["province"]:
                if stopword in chunks[1]:
                    is_separable_by_province_sw = True
                    anchor = chunks[1].rfind(stopword)
                    province = self.remove_special_characters(chunks[1][anchor+len(stopword):]) # province part
                    district = self.remove_special_characters(chunks[1][:anchor]) # district part
                    clear_chunks.append(province)
                    if len(district) > 2 and district not in self.whitelisted_district: clear_chunks.append(district)
            # Else, we can split from the last WINDOW_ALLOWED chars
            if not is_separable_by_province_sw:
              chunk = self.remove_special_characters(chunks[1])
              province = chunk[-len(chunk)//2 - OFFSET:]
              district = chunk[:-len(chunk)//2 + OFFSET]
              clear_chunks.append(province)
              if len(district) > 2 and district not in self.whitelisted_district: clear_chunks.append(district) # Filter trash words
            # We are in the Ward chunk, and it is longer than expected
            if len(chunks[0]) > WINDOW_ALLOWED:
              chunk = self.remove_special_characters(chunks[0])
              is_whitelist = False
              for wl_ward in self.whitelisted_ward:
                  if Solution.BKTree.edit_distance(chunk, wl_ward) <= DIST_ALLOWED:
                      is_whitelist = True
                      next = self.remove_special_characters(wl_ward)
                      break
              if not is_whitelist: next = self.remove_special_characters(chunk[-WINDOW_ALLOWED:])
            else:
              next = self.remove_special_characters(chunks[0])
            clear_chunks.append(next)
            return clear_chunks

          # B.2 Lack of comma to separate ward and province
          ## Identify: If length of District > WINDOW_ALLOWED and not in whitelisted districts
          elif len(chunks[0]) > WINDOW_ALLOWED - 1:
            #print(2)
            # Append Province chunk first
            chunk = self.remove_special_characters(chunks[1])
            for stopword in self.stopwords_dict["province"]:
                if should_elim_prefix_stopword(chunk, stopword):
                    chunks[1] = chunks[1][len(stopword):]
                    break
            clear_chunks.append(self.remove_special_characters(chunks[1]))

            # Remove stopwords from the Ward & District
            chunk = self.remove_special_characters(chunks[0])
            for stopword in self.stopwords_dict["district"] + self.stopwords_dict["ward"]:
                if should_elim_prefix_stopword(chunk, stopword):
                    chunks[0] = chunks[0][len(stopword):]
                    break

            # If we can find a stopword, we can split from it
            is_separable_by_district_sw = False
            chunk = self.remove_special_characters(chunks[0])
            for stopword in self.stopwords_dict["district"]:
                if stopword in chunk:
                    is_separable_by_district_sw = True
                    anchor = chunk.rfind(stopword)
                    district = self.remove_special_characters(chunk[anchor+len(stopword):]) # district part
                    ward = self.remove_special_characters(chunk[:anchor]) # ward part
                    clear_chunks.append(district)
                    clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
            # Else, we can split from the last WINDOW_ALLOWED chars
            if not is_separable_by_district_sw:
              chunk = self.remove_special_characters(chunk)
              district = chunk[-len(chunk)//2 - OFFSET:]
              ward = chunk[:-len(chunk)//2 + OFFSET]
              clear_chunks.append(district)
              clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
            return clear_chunks

        # C. COMMA = 0
        elif len(chunks) == 1:
          # Flags
          is_separable_by_province_sw = False
          is_separable_by_district_sw = False
          chunks[0] = self.remove_special_characters(chunks[0])
          for stopword in self.stopwords_dict["province"]:
              if stopword in chunks[0]:
                  is_separable_by_province_sw = True
                  anchor = chunks[0].rfind(stopword)
                  province = self.remove_special_characters(chunks[0][anchor+len(stopword):]) # province part
                  ward_district = self.remove_special_characters(chunks[0][:anchor]) # district part
                  clear_chunks.append(province)

                  for s_stopword in self.stopwords_dict["district"]:
                      if s_stopword in ward_district:
                          is_separable_by_district_sw = True
                          anchor = ward_district.rfind(s_stopword)
                          district = self.remove_special_characters(ward_district[anchor+len(s_stopword):]) # district part
                          ward = self.remove_special_characters(ward_district[:anchor]) # ward part
                          if len(district) < 3: return clear_chunks
                          clear_chunks.append(district)
                          if len(ward) < 3: return clear_chunks
                          clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
                          return clear_chunks
                  if not is_separable_by_district_sw:
                      chunk = self.remove_special_characters(ward_district)
                      district = chunk[-WINDOW_ALLOWED:]
                      ward = chunk[:-WINDOW_ALLOWED]
                      if len(district) < 3: return clear_chunks
                      clear_chunks.append(district)
                      if len(ward) < 3: return clear_chunks
                      clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
                  return clear_chunks
          if not is_separable_by_province_sw:
              province = chunks[0][-WINDOW_ALLOWED:]
              ward_district = chunks[0][:-WINDOW_ALLOWED]
              clear_chunks.append(province)
              for s_stopword in self.stopwords_dict["district"]:
                  if s_stopword in ward_district:
                      is_separable_by_district_sw = True
                      anchor = ward_district.rfind(s_stopword)
                      district = self.remove_special_characters(ward_district[anchor+len(s_stopword):]) # district part
                      ward = self.remove_special_characters(ward_district[:anchor]) # ward part
                      if len(district) < 3: return clear_chunks
                      clear_chunks.append(district)
                      if len(ward) < 3: return clear_chunks
                      clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
                      return clear_chunks
              if not is_separable_by_district_sw:
                  chunk = self.remove_special_characters(ward_district)
                  district = chunk[-WINDOW_ALLOWED:]
                  ward = chunk[:-WINDOW_ALLOWED]
                  if len(district) < 3: return clear_chunks
                  clear_chunks.append(district)
                  if len(ward) < 3: return clear_chunks
                  clear_chunks.append(ward) if len(ward) <= WINDOW_ALLOWED else clear_chunks.append(ward[-WINDOW_ALLOWED:])
              return clear_chunks
        return ["", "", ""]

    def find_nearest_string(self, tree: BKTree, text: str, is_province=False):
        # Early exit if text is empty or too short and non-numeric.
        if not text or (len(text) < 3 and (not text.isdigit() or is_province)):
            return ""
        result = tree.search(text)
        result.sort(key=lambda x: Solution.BKTree.edit_distance(x, text))
        ans = result[0] if len(result) > 0 else ""
        # Early exit if ans is empty or too short and non-numeric.
        if not ans or (len(text) < 3 and (not text.isdigit() or is_province)):
            return ""
        return ans
    ############### END BKTREE REGION ###############
    # def process(self, s: str):
    #     # Trie search - Province and District
    #     _result, final_candidate, len_remove = self.search_city(s)
    #     province = final_candidate

    #     raw_text_2 = s[:-len_remove] if len_remove != 0 else s
    #     _result, final_candidate, len_remove = self.search_district(raw_text_2, final_candidate)
    #     district = final_candidate

    #     # BKTree - Ward
    #     sanitized_address = self.remove_stopwords_from_address(s)
    #     ward = self.find_nearest_string(self.root_ward, sanitized_address[2]) if len(sanitized_address) > 2 else ""
    #     ward = self.ward_sanitized_map[ward]

    #     return {
    #         "province": province,
    #         "district": district,
    #         "ward": ward,
    #     }
    def process_with_timeout(self, s: str):
        # Trie search - Province and District
        _result, final_candidate, len_remove = self.search_city(s)
        province = final_candidate

        raw_text_2 = s[:-len_remove] if len_remove != 0 else s
        _result, final_candidate, len_remove = self.search_district(raw_text_2, final_candidate)
        district = final_candidate

        # BKTree - Ward
        sanitized_address = self.remove_stopwords_from_address(s)
        ward = self.find_nearest_string(self.root_ward, sanitized_address[2]) if len(sanitized_address) > 2 else ""
        ward = self.ward_sanitized_map[ward]
        return province, district,ward
    # @func_set_timeout(0.07)
    def process(self,s:str):
       try:
            # Sol 1
            province, district, ward = func_timeout(0.07,self.process_with_timeout,args=(s,))
            # Sol 2
            # province, district,ward = self.process_with_timeout(s)
            return {
                "province": province,
                "district": district,
                "ward": ward,
            }
       except (FunctionTimedOut,Exception) as e:
            print("s",s,"========", e, e.with_traceback)
            print("*"*30)
            return{
            "province": 'EXCEPTION',
            "district": 'EXCEPTION',
            "ward": 'EXCEPTION',
            }
    # Using thread
    # def process(self, s: str):
    #     result = {"province": "", "district": "", "ward": ""}

    #     def target():
    #         nonlocal result
    #         try:
    #             province, district, ward = self.process_with_timeout(s)
    #             result = {"province": province, "district": district, "ward": ward}
    #         except Exception as e:
    #             print("Error:", e)

    #     # Run process_with_timeout in a separate thread
    #     thread = threading.Thread(target=target)
    #     thread.start()
    #     thread.join(timeout=0.09)  # Set timeout to 0.1 seconds

    #     if thread.is_alive():
    #         print("Process timed out")
    #         print("address",s)
    #         thread.join(0.01)  # Clean up the thread after timeout

    #     return result

    # Using multiple thread
    # def process(self, s: str):
    #     def worker(q):
    #         try:
    #             result = self.process_with_timeout(s)
    #             q.put(result)
    #         except Exception as e:
    #             q.put(None)

    #     result_queue = multiprocessing.Queue()
    #     process = multiprocessing.Process(target=worker, args=(result_queue,))
    #     process.start()
    #     process.join(timeout=0.09)

    #     if process.is_alive():
    #         print("Process timed out")
    #         process.terminate()
    #         process.join(0.01)
    #         return {"province": "", "district": "", "ward": ""}

    #     return {
    #         "province": result_queue.get()[0],
    #         "district": result_queue.get()[1],
    #         "ward": result_queue.get()[2],
    #     }

# NOTE: DO NOT change this cell
# This cell is for downloading private test
# !rm -rf test.json
# this link is public test
# !gdown --fuzzy https://drive.google.com/file/d/1PBt3U9I3EH885CDhcXspebyKI5Vw6uLB/view?usp=sharing -O test.json

# solution = Solution()

# !python --version

# NOTE: DO NOT change this cell
# This cell is for scoring

TEAM_NAME = 'DEFAULT_NAME'  # This should be your team name
EXCEL_FILE = f'{TEAM_NAME}.xlsx'

import json
import time
with open('test.json') as f:
    data = json.load(f)

summary_only = True
df = []
solution = Solution()
timer = []
correct = 0
for test_idx, data_point in enumerate(data):
    address = data_point["text"]

    ok = 0
    start= 0
    finish = 0
    try:
        start = time.perf_counter_ns()
        # Sol 1
        # limit time 0.07 because thread need to to cleanout after stopthread thread.join(min(.1, timeout / 50.0))
        # result = func_timeout(0.07,solution.process,args=(address,))
        # Sol 2
        result = solution.process(address)
        answer = data_point["result"]
        finish = time.perf_counter_ns()
        timer.append(finish - start)
        ok += int(answer["province"] == result["province"])
        ok += int(answer["district"] == result["district"])
        ok += int(answer["ward"] == result["ward"])
        df.append([
            test_idx,
            address,
            answer["province"],
            result["province"],
            int(answer["province"] == result["province"]),
            answer["district"],
            result["district"],
            int(answer["district"] == result["district"]),
            answer["ward"],
            result["ward"],
            int(answer["ward"] == result["ward"]),
            ok,
            timer[-1] / 1_000_000_000,
        ])
    except Exception as e:
        print(address, e, e.with_traceback)
        df.append([
            test_idx,
            address,
            answer["province"],
            "EXCEPTION",
            0,
            answer["district"],
            "EXCEPTION",
            0,
            answer["ward"],
            "EXCEPTION",
            0,
            0,
            0,
        ])
        # any failure count as a zero correct
        pass
    correct += ok


    if not summary_only:
        # responsive stuff
        print(f"Test {test_idx:5d}/{len(data):5d}")
        print(f"Correct: {ok}/3")
        print(f"Time Executed: {timer[-1] / 1_000_000_000:.4f}")


print(f"-"*30)
total = len(data) * 3
score_scale_10 = round(correct / total * 10, 2)
if len(timer) == 0:
    timer = [0]
max_time_sec = round(max(timer) / 1_000_000_000, 4)
avg_time_sec = round((sum(timer) / len(timer)) / 1_000_000_000, 4)

import pandas as pd

df2 = pd.DataFrame(
    [[correct, total, score_scale_10, max_time_sec, avg_time_sec]],
    columns=['correct', 'total', 'score / 10', 'max_time_sec', 'avg_time_sec',],
)

columns = [
    'ID',
    'text',
    'province',
    'province_student',
    'province_correct',
    'district',
    'district_student',
    'district_correct',
    'ward',
    'ward_student',
    'ward_correct',
    'total_correct',
    'time_sec',
]

df = pd.DataFrame(df)
df.columns = columns

print(f'{TEAM_NAME = }')
print(f'{EXCEL_FILE = }')
print(df2)

# REMOVE THIS LATER
print('---- OVERTIME TESTS ----')
print(df[df['time_sec'] > 0.1][['text', 'time_sec']])
print('----')

# !pip install xlsxwriter
writer = pd.ExcelWriter(EXCEL_FILE, engine='xlsxwriter')
df2.to_excel(writer, index=False, sheet_name='summary')
df.to_excel(writer, index=False, sheet_name='details')
writer.close()

# import threading
# import time

# class Solution:
#     def process(self):
#         # Hàm sẽ được thực thi trong thread
#         def run_in_thread():
#             for i in range(5):
#                 print(f"Thread is running: {i}")
#                 # time.sleep(1)  # Giả lập công việc

#         # Tạo một thread
#         my_thread = threading.Thread(target=run_in_thread)

#         # Bắt đầu thread
#         my_thread.start()

#         # Chờ cho thread hoàn thành (nếu cần)
#         my_thread.join(4)  # Nếu bạn muốn chờ cho thread hoàn thành trước khi tiếp tục

# # Sử dụng lớp
# solution = Solution()
# start = time.perf_counter_ns()
# solution.process()
# finish = time.perf_counter_ns()
# print('finish',(finish - start)/ 1_000_000_000)